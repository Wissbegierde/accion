<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Curva Braquistócrona - Completo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }

        .control-group label {
            min-width: 180px;
            font-weight: 600;
            color: #555;
        }

        .control-group input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .control-group span {
            min-width: 50px;
            font-weight: bold;
            color: #667eea;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        #resetBtn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        #startBtn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        #addCurveBtn {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            color: #333;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .info ul {
            margin-left: 20px;
        }

        .info li {
            margin-bottom: 8px;
            color: #555;
        }

        #simulationCanvas {
            display: block;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            cursor: default;
        }

        .results {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .results h3 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        #times {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }

        #times > div {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            text-align: center;
            min-width: 200px;
        }

        #times span {
            font-size: 1.2em;
            display: block;
            margin-top: 5px;
        }

        .status {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            #simulationCanvas {
                width: 100%;
                height: auto;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-group label {
                min-width: auto;
            }
            
            .buttons {
                flex-direction: column;
            }
            
            #times {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🏁 Simulador de la Curva Braquistócrona</h1>
        
        <div class="status" id="statusDisplay">
            ✨ Listo para simular - Arrastra los puntos A y B para cambiar la configuración
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="ballWeight">⚖️ Peso de la bolita (kg):</label>
                <input type="range" id="ballWeight" min="0.1" max="2" step="0.1" value="1">
                <span id="weightDisplay">1.0</span>
            </div>
            
            <div class="control-group">
                <label for="ballRadius">🔘 Radio de la bolita (px):</label>
                <input type="range" id="ballRadius" min="8" max="25" step="1" value="15">
                <span id="radiusDisplay">15</span>
            </div>
            
            <div class="buttons">
                <button id="resetBtn">🔄 Reiniciar</button>
                <button id="startBtn">🚀 Iniciar Simulación</button>
                <button id="addCurveBtn">➕ Agregar Punto de Control</button>
            </div>
        </div>
        
        <div class="info">
            <p><strong>📋 Instrucciones:</strong></p>
            <ul>
                <li>🔴 <strong>Línea roja:</strong> Trayectoria recta (la más obvia)</li>
                <li>🔵 <strong>Línea azul:</strong> Curva braquistócrona (¡la más rápida!)</li>
                <li>🟢 <strong>Línea verde:</strong> Curva personalizable</li>
                <li>🖱️ <strong>Arrastra</strong> los puntos A y B para cambiar posiciones</li>
                <li>🎯 <strong>Arrastra</strong> los puntos naranjas numerados para modificar la curva verde</li>
            </ul>
        </div>
        
        <canvas id="simulationCanvas" width="1200" height="800"></canvas>
        
        <div class="results">
            <h3>⏱️ Tiempos de llegada (en tiempo real):</h3>
            <div id="times">
                <div>🔴 Línea recta: <span id="straightTime">-</span>s</div>
                <div>🔵 Braquistócrona: <span id="brachistochroneTime">-</span>s</div>
                <div>🟢 Curva personalizada: <span id="customTime">-</span>s</div>
            </div>
        </div>
    </div>
    
    <script>
        class BrachistochroneSimulator {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupEventListeners();
                this.initializeSimulation();
            }

            initializeSimulation() {
                // Fuerza valores iniciales para A y B
                this.pointA = { x: 150, y: 100 };
                this.pointB = { x: 1050, y: 700 };
                
                // Current simulation state
                this.isSimulating = false;
                this.balls = [];
                this.startTime = 0;
                this.animationId = null;
                this.times = {
                    straight: null,
                    brachistochrone: null,
                    custom: null
                };

                // Dragging state
                this.isDragging = false;
                this.dragTarget = null; // 'A', 'B', or custom point index
                this.customCurvePoints = [];

                // Initial custom curve (simple arc)
                this.generateDefaultCustomCurve();
                
                this.updateStatus("Listo para simular - Arrastra los puntos A y B para cambiar la configuración");
                this.draw();
            }

            updateStatus(message) {
                document.getElementById('statusDisplay').textContent = "✨ " + message;
            }

            setupEventListeners() {
                // Canvas mouse events for point manipulation
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Control sliders
                document.getElementById('ballWeight').addEventListener('input', (e) => {
                    document.getElementById('weightDisplay').textContent = e.target.value;
                });

                document.getElementById('ballRadius').addEventListener('input', (e) => {
                    document.getElementById('radiusDisplay').textContent = e.target.value;
                });

                // Buttons
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSimulation());
                document.getElementById('startBtn').addEventListener('click', () => this.startSimulation());
                document.getElementById('addCurveBtn').addEventListener('click', () => this.addCustomCurvePoint());
            }

            handleMouseDown(e) {
                if (this.isSimulating) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if clicking near point A or B
                const distanceToA = Math.sqrt((x - this.pointA.x) ** 2 + (y - this.pointA.y) ** 2);
                const distanceToB = Math.sqrt((x - this.pointB.x) ** 2 + (y - this.pointB.y) ** 2);

                if (distanceToA < 30) {
                    this.isDragging = true;
                    this.dragTarget = 'A';
                    this.canvas.style.cursor = 'grabbing';
                    this.updateStatus("Arrastrando punto A");
                    return;
                } else if (distanceToB < 30) {
                    this.isDragging = true;
                    this.dragTarget = 'B';
                    this.canvas.style.cursor = 'grabbing';
                    this.updateStatus("Arrastrando punto B");
                    return;
                }

                // Check if clicking on a custom curve control point
                for (let i = 0; i < this.customCurvePoints.length; i++) {
                    const point = this.customCurvePoints[i];
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    if (distance < 25) {
                        this.isDragging = true;
                        this.dragTarget = i;
                        this.canvas.style.cursor = 'grabbing';
                        this.updateStatus(`Arrastrando punto de control ${i + 1}`);
                        return;
                    }
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.isDragging && !this.isSimulating) {
                    if (this.dragTarget === 'A') {
                        this.pointA = { x: Math.max(30, Math.min(x, this.canvas.width - 30)), 
                                       y: Math.max(30, Math.min(y, this.canvas.height - 30)) };
                        this.generateDefaultCustomCurve();
                    } else if (this.dragTarget === 'B') {
                        this.pointB = { x: Math.max(30, Math.min(x, this.canvas.width - 30)), 
                                       y: Math.max(30, Math.min(y, this.canvas.height - 30)) };
                        this.generateDefaultCustomCurve();
                    } else if (typeof this.dragTarget === 'number') {
                        this.customCurvePoints[this.dragTarget] = { 
                            x: Math.max(30, Math.min(x, this.canvas.width - 30)), 
                            y: Math.max(30, Math.min(y, this.canvas.height - 30)) 
                        };
                    }
                    this.draw();
                } else {
                    // Change cursor when hovering over draggable points
                    const distanceToA = Math.sqrt((x - this.pointA.x) ** 2 + (y - this.pointA.y) ** 2);
                    const distanceToB = Math.sqrt((x - this.pointB.x) ** 2 + (y - this.pointB.y) ** 2);
                    
                    let overDraggable = distanceToA < 30 || distanceToB < 30;
                    
                    if (!overDraggable) {
                        for (let point of this.customCurvePoints) {
                            const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                            if (distance < 25) {
                                overDraggable = true;
                                break;
                            }
                        }
                    }
                    
                    this.canvas.style.cursor = overDraggable ? 'grab' : 'default';
                }
            }

            handleMouseUp(e) {
                if (this.isDragging) {
                    this.updateStatus("Configuración actualizada - ¡Listo para simular!");
                }
                this.isDragging = false;
                this.dragTarget = null;
                this.canvas.style.cursor = 'default';
            }

            generateDefaultCustomCurve() {
                // Generate a simple arc as default custom curve
                const midX = (this.pointA.x + this.pointB.x) / 2;
                const midY = (this.pointA.y + this.pointB.y) / 2 + 150;
                
                this.customCurvePoints = [
                    { x: midX - 150, y: midY },
                    { x: midX, y: midY + 75 },
                    { x: midX + 150, y: midY }
                ];
            }

            addCustomCurvePoint() {
                if (this.isSimulating) return;
                
                const midX = (this.pointA.x + this.pointB.x) / 2;
                const midY = (this.pointA.y + this.pointB.y) / 2;
                
                this.customCurvePoints.push({ 
                    x: midX + (Math.random() - 0.5) * 300, 
                    y: midY + (Math.random() - 0.5) * 150 
                });
                
                this.updateStatus(`Punto de control ${this.customCurvePoints.length} agregado`);
                this.draw();
            }

            // Calculate brachistochrone curve using proper cycloid equations
            calculateBrachistochroneCurve() {
                const points = [];
                const numPoints = 50;
                
                const dx = this.pointB.x - this.pointA.x;
                const dy = this.pointB.y - this.pointA.y;
                
                if (dy <= 0) {
                    // If point B is above or at same level as A, use straight line
                    return this.calculateStraightLine();
                }
                
                // Calculate the parameter for the cycloid that passes through both points
                const R = dy / 2; // Radius of the generating circle
                const theta_max = Math.PI; // Parameter range
                
                for (let i = 0; i <= numPoints; i++) {
                    const t = (i / numPoints) * theta_max;
                    
                    // Cycloid equations
                    const cycloid_x = R * (t - Math.sin(t));
                    const cycloid_y = R * (1 - Math.cos(t));
                    
                    // Scale and translate to fit between A and B
                    const scale_x = dx / (R * (theta_max - Math.sin(theta_max)));
                    const scale_y = dy / (R * (1 - Math.cos(theta_max)));
                    
                    const x = this.pointA.x + cycloid_x * scale_x;
                    const y = this.pointA.y + cycloid_y * scale_y;
                    
                    points.push({ x, y });
                }
                
                return points;
            }

            // Calculate straight line points
            calculateStraightLine() {
                const points = [];
                const numPoints = 50;
                
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    const x = this.pointA.x + t * (this.pointB.x - this.pointA.x);
                    const y = this.pointA.y + t * (this.pointB.y - this.pointA.y);
                    points.push({ x, y });
                }
                
                return points;
            }

            // Calculate custom curve points using proportional distribution
            calculateCustomCurve() {
                if (this.customCurvePoints.length === 0) {
                    return this.calculateStraightLine();
                }

                const allPoints = [this.pointA, ...this.customCurvePoints, this.pointB];
                const points = [];
                const totalPointsNeeded = 50;

                // Calcular la distancia total de la curva para distribuir puntos proporcionalmente
                let totalDistance = 0;
                const segmentDistances = [];
                
                for (let seg = 0; seg < allPoints.length - 1; seg++) {
                    const p0 = allPoints[seg];
                    const p1 = allPoints[seg + 1];
                    const dist = Math.sqrt((p1.x - p0.x) ** 2 + (p1.y - p0.y) ** 2);
                    segmentDistances.push(dist);
                    totalDistance += dist;
                }

                // Distribuir puntos proporcionalmente según la longitud de cada segmento
                let pointsUsed = 0;
                for (let seg = 0; seg < allPoints.length - 1; seg++) {
                    const p0 = allPoints[seg];
                    const p1 = allPoints[seg + 1];
                    
                    // Calcular cuántos puntos necesita este segmento
                    const segmentRatio = segmentDistances[seg] / totalDistance;
                    const pointsForSegment = seg === allPoints.length - 2 
                        ? totalPointsNeeded - pointsUsed  // El último segmento usa todos los puntos restantes
                        : Math.max(1, Math.round(totalPointsNeeded * segmentRatio));
                    
                    // Generar puntos para este segmento
                    for (let i = 0; i < pointsForSegment; i++) {
                        const t = pointsForSegment === 1 ? 0 : i / (pointsForSegment - 1);
                        const x = p0.x + t * (p1.x - p0.x);
                        const y = p0.y + t * (p1.y - p0.y);
                        points.push({ x, y });
                    }
                    
                    pointsUsed += pointsForSegment;
                }

                // Forzar que el último punto sea exactamente el punto B
                if (points.length > 0) {
                    points[points.length - 1] = { x: this.pointB.x, y: this.pointB.y };
                }

                // Asegurar que el primer punto sea exactamente el punto A
                if (points.length > 0) {
                    points[0] = { x: this.pointA.x, y: this.pointA.y };
                }

                console.log(`Curva personalizada: ${points.length} puntos generados con distribución proporcional, desde A hasta B`);
                
                return points;
            }

            // Calcula el tiempo de llegada para una curva usando integración numérica
            calculateCurveTime(curve) {
                try {
                    const g = 9.81; // gravedad en m/s^2
                    const PIXELS_PER_METER = 100; // Escala: 100 píxeles = 1 metro
                    console.log('Calculando tiempo para curva con', curve.length, 'puntos');
                    console.log('Punto inicial A:', this.pointA, 'Punto final B:', this.pointB);
                    
                    let totalTime = 0;
                    for (let i = 0; i < curve.length - 1; i++) {
                        const p0 = curve[i];
                        const p1 = curve[i + 1];
                        const dx = p1.x - p0.x;
                        const dy = p1.y - p0.y;
                        const ds = Math.sqrt(dx * dx + dy * dy) / PIXELS_PER_METER; // distancia en metros
                        
                        // Altura promedio del segmento en metros (hacia abajo es positivo)
                        const avgY = (p0.y + p1.y) / 2;
                        const h = Math.max(0.01, (avgY - this.pointA.y) / PIXELS_PER_METER); // altura desde A en metros
                        
                        // Velocidad basada en conservación de energía: v = √(2gh)
                        const v = Math.sqrt(2 * g * h); // velocidad en m/s
                        const dt = ds / v; // tiempo del segmento
                        
                        if (i < 5) {
                            console.log(`Segmento ${i}: ds=${ds.toFixed(4)}m, h=${h.toFixed(4)}m, v=${v.toFixed(2)}m/s, dt=${dt.toFixed(4)}s`);
                        }
                        
                        totalTime += dt;
                    }
                    
                    console.log('Tiempo total calculado:', totalTime.toFixed(3), 'segundos');
                    return totalTime;
                } catch (err) {
                    console.error('Error en calculateCurveTime:', err);
                    return 5; // fallback time
                }
            }

            // Ball movement para curva personalizada: usa lógica de longitud total de curva
            simulateCustomBallMovement(curve, ball, deltaTime) {
                try {
                    if (ball.pathProgress >= 1.0) {
                        if (!ball.finished) {
                            ball.finished = true;
                            const endTime = Date.now();
                            const totalTime = (endTime - ball.startTime) / 1000;
                            document.getElementById(ball.timeId).textContent = totalTime.toFixed(3);
                            console.log(`Pelota ${ball.curveType} terminó en ${totalTime.toFixed(3)}s`);
                        }
                        return;
                    }

                    // Asegurar que el progreso no exceda 1.0
                    ball.pathProgress = Math.min(ball.pathProgress, 1.0);
                    
                    // Encontrar posición actual en la curva
                    const exactIndex = ball.pathProgress * (curve.length - 1);
                    const currentIndex = Math.floor(exactIndex);
                    const nextIndex = Math.min(currentIndex + 1, curve.length - 1);
                    
                    // Si ya llegamos al final de la curva
                    if (currentIndex >= curve.length - 1) {
                        ball.x = curve[curve.length - 1].x;
                        ball.y = curve[curve.length - 1].y;
                        ball.pathProgress = 1.0;
                        return;
                    }
                    
                    const currentPoint = curve[currentIndex];
                    const nextPoint = curve[nextIndex];
                    const localProgress = exactIndex - currentIndex;
                    
                    // Posición actual interpolada
                    ball.x = currentPoint.x + localProgress * (nextPoint.x - currentPoint.x);
                    ball.y = currentPoint.y + localProgress * (nextPoint.y - currentPoint.y);

                    // Calcular velocidad actual basada en la altura
                    const g = 9.81;
                    const PIXELS_PER_METER = 100;
                    const h = Math.max(0.01, (ball.y - this.pointA.y) / PIXELS_PER_METER); // altura desde A
                    const velocity = Math.sqrt(2 * g * h); // velocidad en m/s
                    
                    // Calcular la longitud total de la curva personalizada
                    const totalCurveLength = this.calculateCustomCurveLength(curve) / PIXELS_PER_METER;
                    
                    // Calcular cuánto avanzar en este frame basado en la longitud total
                    const distanceToMove = velocity * deltaTime; // metros a moverse en este frame
                    const progressIncrement = distanceToMove / totalCurveLength;
                    
                    ball.pathProgress += progressIncrement;
                    ball.pathProgress = Math.min(ball.pathProgress, 1.0);

                    // Actualizar timer en tiempo real
                    if (!ball.finished) {
                        const currentTime = (Date.now() - ball.startTime) / 1000;
                        document.getElementById(ball.timeId).textContent = currentTime.toFixed(3);
                    }
                    
                    // Debug para las primeras frames
                    if (ball.debugCounter < 5) {
                        console.log(`${ball.curveType}: progress=${ball.pathProgress.toFixed(4)}, velocity=${velocity.toFixed(2)}m/s, pos=(${ball.x.toFixed(1)}, ${ball.y.toFixed(1)}), totalLength=${totalCurveLength.toFixed(2)}m`);
                        ball.debugCounter = (ball.debugCounter || 0) + 1;
                    }
                    
                } catch (err) {
                    console.error('Error en simulateCustomBallMovement:', err);
                }
            }

            // Función auxiliar para calcular la longitud total de la curva personalizada
            calculateCustomCurveLength(curve) {
                let totalLength = 0;
                for (let i = 0; i < curve.length - 1; i++) {
                    const p0 = curve[i];
                    const p1 = curve[i + 1];
                    const dx = p1.x - p0.x;
                    const dy = p1.y - p0.y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                }
                return totalLength;
            }

            // Ball movement: cada bolita avanza según su velocidad real en cada punto
            simulateBallMovement(curve, ball, deltaTime) {
                try {
                    if (ball.pathProgress >= 1.0) {
                        if (!ball.finished) {
                            ball.finished = true;
                            const endTime = Date.now();
                            const totalTime = (endTime - ball.startTime) / 1000;
                            document.getElementById(ball.timeId).textContent = totalTime.toFixed(3);
                            console.log(`Pelota ${ball.curveType} terminó en ${totalTime.toFixed(3)}s`);
                        }
                        return;
                    }

                    // Encontrar posición actual en la curva
                    const currentIndex = Math.floor(ball.pathProgress * (curve.length - 1));
                    const nextIndex = Math.min(currentIndex + 1, curve.length - 1);
                    
                    if (currentIndex >= curve.length - 1) {
                        ball.pathProgress = 1.0;
                        return;
                    }
                    
                    const currentPoint = curve[currentIndex];
                    const nextPoint = curve[nextIndex];
                    const localProgress = (ball.pathProgress * (curve.length - 1)) - currentIndex;
                    
                    // Posición actual interpolada
                    ball.x = currentPoint.x + localProgress * (nextPoint.x - currentPoint.x);
                    ball.y = currentPoint.y + localProgress * (nextPoint.y - currentPoint.y);

                    // Calcular velocidad actual basada en la altura
                    const g = 9.81;
                    const PIXELS_PER_METER = 100;
                    const h = Math.max(0.01, (ball.y - this.pointA.y) / PIXELS_PER_METER); // altura desde A
                    const velocity = Math.sqrt(2 * g * h); // velocidad en m/s
                    
                    // Calcular distancia del segmento actual
                    const dx = nextPoint.x - currentPoint.x;
                    const dy = nextPoint.y - currentPoint.y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy) / PIXELS_PER_METER; // en metros
                    
                    // Calcular cuánto avanzar en este frame
                    const distanceToMove = velocity * deltaTime; // metros a moverse en este frame
                    const progressIncrement = distanceToMove / segmentLength / (curve.length - 1);
                    
                    ball.pathProgress += progressIncrement;
                    ball.pathProgress = Math.min(ball.pathProgress, 1.0);

                    // Actualizar timer en tiempo real
                    if (!ball.finished) {
                        const currentTime = (Date.now() - ball.startTime) / 1000;
                        document.getElementById(ball.timeId).textContent = currentTime.toFixed(3);
                    }
                    
                    // Debug para las primeras frames
                    if (ball.debugCounter < 5) {
                        console.log(`${ball.curveType}: progress=${ball.pathProgress.toFixed(4)}, velocity=${velocity.toFixed(2)}m/s, pos=(${ball.x.toFixed(1)}, ${ball.y.toFixed(1)})`);
                        ball.debugCounter = (ball.debugCounter || 0) + 1;
                    }
                    
                } catch (err) {
                    console.error('Error en simulateBallMovement:', err);
                }
            }

            startSimulation() {
                try {
                    if (this.isSimulating) return;

                    console.log('=== INICIANDO SIMULACIÓN ===');
                    this.isSimulating = true;
                    this.updateStatus("🏁 ¡Simulación en curso! Observa cuál llega primero...");

                    const straightCurve = this.calculateStraightLine();
                    const brachistochroneCurve = this.calculateBrachistochroneCurve();
                    const customCurve = this.calculateCustomCurve();

                    console.log('Curvas calculadas:', {
                        straight: straightCurve.length,
                        brachistochrone: brachistochroneCurve.length,
                        custom: customCurve.length
                    });

                    // Reset timers
                    document.getElementById('straightTime').textContent = '0.000';
                    document.getElementById('brachistochroneTime').textContent = '0.000';
                    document.getElementById('customTime').textContent = '0.000';

                    const radius = parseInt(document.getElementById('ballRadius').value);
                    const now = Date.now();
                    
                    // Crear pelotas con posición inicial
                    this.balls = [
                        { 
                            x: this.pointA.x, 
                            y: this.pointA.y, 
                            pathProgress: 0, 
                            finished: false, 
                            color: '#ff4757', 
                            radius, 
                            curveType: 'straight', 
                            timeId: 'straightTime', 
                            startTime: now,
                            debugCounter: 0
                        },
                        { 
                            x: this.pointA.x, 
                            y: this.pointA.y, 
                            pathProgress: 0, 
                            finished: false, 
                            color: '#3742fa', 
                            radius, 
                            curveType: 'brachistochrone', 
                            timeId: 'brachistochroneTime', 
                            startTime: now,
                            debugCounter: 0
                        },
                        { 
                            x: this.pointA.x, 
                            y: this.pointA.y, 
                            pathProgress: 0, 
                            finished: false, 
                            color: '#2ed573', 
                            radius, 
                            curveType: 'custom', 
                            timeId: 'customTime', 
                            startTime: now,
                            debugCounter: 0
                        }
                    ];

                    console.log('Pelotas creadas:', this.balls.map(b => ({type: b.curveType, pos: [b.x, b.y]})));
                    
                    this.lastFrameTime = now;
                    this.animate();
                } catch (err) {
                    console.error('Error en startSimulation:', err);
                }
            }

            animate() {
                try {
                    if (!this.isSimulating) return;

                    const now = Date.now();
                    const deltaTime = (now - (this.lastFrameTime || now)) / 1000; // tiempo en segundos desde el último frame
                    this.lastFrameTime = now;
                    
                    // Máximo deltaTime para evitar saltos grandes
                    const clampedDeltaTime = Math.min(deltaTime, 1/30); // máximo 30fps mínimo

                    const straightCurve = this.calculateStraightLine();
                    const brachistochroneCurve = this.calculateBrachistochroneCurve();
                    const customCurve = this.calculateCustomCurve();

                    // Mover cada pelota según su física específica
                    this.balls.forEach(ball => {
                        if (ball.curveType === 'straight') {
                            this.simulateBallMovement(straightCurve, ball, clampedDeltaTime);
                        } else if (ball.curveType === 'brachistochrone') {
                            this.simulateBallMovement(brachistochroneCurve, ball, clampedDeltaTime);
                        } else if (ball.curveType === 'custom') {
                            this.simulateCustomBallMovement(customCurve, ball, clampedDeltaTime);
                        }
                    });

                    this.draw();

                    // Continuar animación si no todas han terminado
                    const allFinished = this.balls.every(ball => ball.finished);
                    if (!allFinished) {
                        this.animationId = requestAnimationFrame(() => this.animate());
                    } else {
                        this.isSimulating = false;
                        this.animationId = null;
                        const times = {
                            straight: parseFloat(document.getElementById('straightTime').textContent),
                            brachistochrone: parseFloat(document.getElementById('brachistochroneTime').textContent),
                            custom: parseFloat(document.getElementById('customTime').textContent)
                        };
                        
                        // Determinar ganador
                        let winner = 'Empate';
                        const minTime = Math.min(times.straight, times.brachistochrone, times.custom);
                        if (times.brachistochrone === minTime) winner = 'Braquistócrona 🔵';
                        else if (times.straight === minTime) winner = 'Línea recta 🔴';
                        else if (times.custom === minTime) winner = 'Curva personalizada 🟢';
                        
                        this.updateStatus(`¡Simulación completada! Ganador: ${winner} 🏆`);
                        console.log('=== SIMULACIÓN TERMINADA ===');
                        console.log('Tiempos finales:', times);
                        console.log('Ganador:', winner);
                    }
                } catch (err) {
                    console.error('Error en animate:', err);
                }
            }

            resetSimulation() {
                this.isSimulating = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                this.balls = [];
                this.times = { straight: null, brachistochrone: null, custom: null };
                
                document.getElementById('straightTime').textContent = '-';
                document.getElementById('brachistochroneTime').textContent = '-';
                document.getElementById('customTime').textContent = '-';
                
                this.updateStatus("Simulación reiniciada - Listo para comenzar de nuevo");
                this.draw();
            }

            drawCurve(points, color, width = 6) {
                if (points.length === 0) return;
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                
                this.ctx.stroke();
            }

            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background grid
                this.drawGrid();
                
                // Draw curves
                const straightCurve = this.calculateStraightLine();
                const brachistochroneCurve = this.calculateBrachistochroneCurve();
                const customCurve = this.calculateCustomCurve();
                
                this.drawCurve(straightCurve, '#ff4757', 6);
                this.drawCurve(brachistochroneCurve, '#3742fa', 6);
                this.drawCurve(customCurve, '#2ed573', 6);
                
                // Draw points A and B
                this.drawPoint(this.pointA, '#333', 22, 'A');
                this.drawPoint(this.pointB, '#333', 22, 'B');
                
                // Draw custom curve control points
                this.customCurvePoints.forEach((point, index) => {
                    this.drawPoint(point, '#ffa502', 15, (index + 1).toString());
                });
                
                // Draw balls if simulating - IMPORTANT: Draw balls on top
                this.balls.forEach(ball => {
                    this.drawBall(ball);
                });
                
                // Draw legend
                this.drawLegend();
            }

            drawGrid() {
                this.ctx.strokeStyle = '#f8f9fa';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawPoint(point, color, radius, label) {
                // Draw outer ring for better visibility
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, radius + 4, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw shadow
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath();
                this.ctx.arc(point.x + 3, point.y + 3, radius, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                this.ctx.fill();
                
                if (label) {
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(label, point.x, point.y);
                }
            }

            drawBall(ball) {
                // Add shadow effect
                this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                this.ctx.beginPath();
                this.ctx.arc(ball.x + 5, ball.y + 5, ball.radius, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw ball
                this.ctx.fillStyle = ball.color;
                this.ctx.beginPath();
                this.ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add highlight
                this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                this.ctx.beginPath();
                this.ctx.arc(ball.x - ball.radius/3, ball.y - ball.radius/3, ball.radius/3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add rim light
                this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(ball.x, ball.y, ball.radius - 2, 0, 2 * Math.PI);
                this.ctx.stroke();
                
                // Add ball number for identification
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText((this.balls.indexOf(ball) + 1).toString(), ball.x, ball.y);
            }

            drawLegend() {
                const x = 40;
                const y = this.canvas.height - 180;
                
                // Background for legend
                this.ctx.fillStyle = 'rgba(255,255,255,0.95)';
                this.ctx.fillRect(x - 20, y - 20, 280, 120);
                this.ctx.strokeStyle = '#ddd';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(x - 20, y - 20, 280, 120);
                
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'left';
                
                // Straight line
                this.ctx.fillStyle = '#ff4757';
                this.ctx.fillRect(x, y, 30, 6);
                this.ctx.fillStyle = '#333';
                this.ctx.fillText('🔴 Línea recta', x + 40, y + 10);
                
                // Brachistochrone
                this.ctx.fillStyle = '#3742fa';
                this.ctx.fillRect(x, y + 30, 30, 6);
                this.ctx.fillStyle = '#333';
                this.ctx.fillText('🔵 Braquistócrona', x + 40, y + 40);
                
                // Custom curve
                this.ctx.fillStyle = '#2ed573';
                this.ctx.fillRect(x, y + 60, 30, 6);
                this.ctx.fillStyle = '#333';
                this.ctx.fillText('🟢 Curva personalizada', x + 40, y + 70);
            }
        }

        // Initialize the simulator when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new BrachistochroneSimulator();
        });
    </script>
</body>
</html> 